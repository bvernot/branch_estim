ll_ret_to_dt2(x.em, 'args)
ll_ret_to_dt <- function(my.ret, sites.cat) {
data.table(max.ll = my.ret$max.ll,
branch = my.ret$branch,
branchtime = my.ret$branchtime,
branchtime.rel = (my.ret$branchtime - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)) /
(sims.dat$bounds.for.branch(my.ret$branch, 'high', sims.dat) - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)),
mh_contam_deamT = my.ret$dt.theta[rg %like% 'deam_TRUE', mh_contam],
faunal_prop_deamT = my.ret$dt.theta[rg %like% 'deam_TRUE', faunal_prop],
mh_contam_deamF = my.ret$dt.theta[rg %like% 'deam_FALSE', mh_contam],
faunal_prop_deamF = my.ret$dt.theta[rg %like% 'deam_FALSE', faunal_prop],
max.ll.iter = length(my.ret$ll.trace),
next.ll = tail(my.ret$ll.trace,2)[1],
sites.cat = sites.cat,
lib = args$libs,
tag = args$tag)
}
# ll_ret_to_dt(my.ret$a, args$site_cat)
sed_EM_allbranch <- function(dt.sed.analysis, sims.dat, err_rate = 0.001, max.iter = 20, ll.converge = 0, p_h_method = 'full') {
ret = list()
max.ll = -1e200
for (my.branch in sims.dat$branches) {
ret[[my.branch]] <- sed_EM(dt.sed.analysis = dt.sed.analysis, sims.dat = sims.dat, my.branch = my.branch, err_rate = err_rate, max.iter = max.iter, ll.converge = ll.converge, p_h_method = p_h_method)
if (ret[[my.branch]]$max.ll > max.ll) ret$max <- ret[[my.branch]]
}
ret
}
# sed_EM_allbranch <- function(dt.sed.analysis, sims.dat, err_rate = 0.001, max.iter = 20) {
#   max.ll = -1e200
#   my.ret <- foreach (my.branch = sims.dat$branches, .combine = c) %dopar% {
#     cat(my.branch, '\n')
#     ret = list()
#     ret[[my.branch]] <- sed_EM(dt.sed.analysis = dt.sed.analysis, sims.dat = sims.dat, my.branch = my.branch, err_rate = err_rate, max.iter = max.iter)
#     ret[[my.branch]]
#   }
#   # if (ret$max.ll > max.ll) ret$max <- ret[[my.branch]]
#   my.ret
# }
#################################
## the original code for calculating a composite likelihood
#################################
#
# # test.gts <- fread('~/Google Drive/soil_dna_capture/all_simple_gts.deam.tsv.gz')
# # test.gts <- fread('output_v4/all_simple_gts.deam.tsv.gz')
# # test.gts <- fread('zcat output_v4/all_simple_gts.deam.tsv.gz | head -n1000')
#
#
# dt.sims.p = fread('~/Google Drive/soil_dna_capture/simulate_demog/dt.sims.p.simfiles004.txt')
# dt.sims.p.coarse = dt.sims.p[!endsWith(paste(time), '01') | endsWith(paste(time), '001')]
apply_contam <- function(dt, contam=0.05) {
dt = data.table(dt)
## contam % of the time, when we should see a 1, we'll see a 0
dt[sed == 1, p := p * (1-contam)]
## also increase 0 p by the same amount
dt[sed == 0, p := p + (1-p) * contam]
dt[, model.contam := contam]
return(dt)
}
# a = apply_contam(dt.sims.p)
demog_composite_liks <- function(dt.sims.p, test.gts, model.contam = NULL) {
## dt.sims.p should be of this format:
# > dt.sims.p
#    v c a sed    time branch      p
# 1: 0 0 0   0 0.89999      a 0.9928
# 2: 0 0 0   0 0.89999      c 0.9887
# 3: 0 0 0   0 0.89999      v 0.9891
# 4: 0 0 0   0 0.91000      a 0.9920
## test.gts should be
# test.gts <- fread('~/Google Drive/soil_dna_capture/all_simple_gts.deam.tsv.gz')
#       libname v c a sed deam53              lib  pct_ref pct_ref.low
# 1:     A16036 0 0 0   0   TRUE           A16036 1.000000   0.6456696
# 2:     A16036 2 2 2   0   TRUE           A16036 1.000000   0.6456696
# 3:     A16036 0 2 0   0   TRUE           A16036 1.000000   0.6456696
# 4:     A16036 0 0 0   0   TRUE           A16036 1.000000   0.6456696
## although I think only v,c,a,libname,lib,sed are used?
if ('vind.gt' %in% colnames(test.gts)) {
# also save a1/a2/pantro for pairing w/ MH freqs?
test.gts <- test.gts[!is.na(read_base.gt) &
!is.na(vind.gt) &
!is.na(chag.gt) &
!is.na(altai.gt),
.(v = vind.gt, c = chag.gt, a = altai.gt,
sed = read_base.gt/2,
lib, libname)]
}
test.gts = test.gts[!(v == c & v == a)]
if (!is.null(model.contam)) {
if (!(length(model.contam) > 0 && is.numeric(model.contam))) model.contam = seq(0,.3,.05)
dt.sims.p = do.call(rbind, lapply(model.contam, function(x) apply_contam(dt.sims.p, x)))
} else {
dt.sims.p[, model.contam := 0]
}
setkey(dt.sims.p, time, branch, model.contam)
sim.vals = dt.sims.p[, .(time,branch,model.contam)]  %>% unique
test.gts.t = foreach(x = sim.vals[,.I], .combine = rbind) %do% {
x = sim.vals[x]
print(x)
x = merge(test.gts, dt.sims.p[x], by=c('v','c','a','sed'))
x[, .(ll.og=sum(log(p)),
ll=log(choose(.N,24))+sum(log(p))), .(time,branch,model.contam,libname)]
}
test.gts.t[, ll.max := max(ll), libname]
test.gts.t[, ll.k := exp(ll.max-ll)]
ret = list()
ret[['full.tree']] <- test.gts.t
ret[['max.model']] <- test.gts.t[max(ll) == ll]
ll.max.contam = ret[['max.model']][, model.contam]
ret[['k20.ci']] <- test.gts.t[ll.k < 20 & model.contam == ll.max.contam, range(time), branch]
ret[['k20.contam.ci']] <- test.gts.t[ll.k < 20, range(model.contam)]
return(ret)
}
if (F) {
libs.150 <- test.gts[, .N, lib][N > 150, lib]
cat('a.s.lib\n')
a.s.lib <- test.gts[lib %in% libs.150, demog_liks(dt.sims.p, .SD, model.contam = T)$full.tree, .(lib,libname)]
cat('a.s.libname\n')
a.s.libname <- test.gts[lib %in% libs.150, demog_liks(dt.sims.p, .SD, model.contam = T)$full.tree, libname]
date()
}
#################
## test method by "simulating" data
simulate_data_sed <- function(method, my.t, sims.dat, my.mh_contam = 0, my.faunal_prop = 0, err_rate = 0.001, nsites = 1002) {
dt.sed.poly.tst <- data.table(v_gt=0:2, c_gt=0:2, a_gt=0:2, d_gt=0, f_mh=rbeta(nsites, .2, 5), rg = 'hey_rg', x = 1:nsites)
dt.sed.poly.tst[, v_gt := sample(v_gt)]
dt.sed.poly.tst[, c_gt := sample(c_gt)]
dt.sed.poly.tst[, a_gt := sample(a_gt)]
if (method == 'bt')  dt.sed.poly.tst[, p_h_der := my.t]
if (method == 'bt2') dt.sed.poly.tst[, p_h_der := my.t / (c_gt+1)]
if (method == 'bt3') dt.sed.poly.tst[, p_h_der := ifelse(a_gt == 0, 0.001, my.t / (c_gt+1))]
if (method == 'simple') {
dt.sed.poly.tst[, p_h_der := sims.dat$simple_p_given_b_t_arcs('v', my.t,
list(v_gt,c_gt,a_gt,d_gt),
sims.dat),
.(v_gt,c_gt,a_gt,d_gt)]
}
if (method == 'full') {
dt.sed.poly.tst[, p_h_der := sims.dat$p_gt_given_b_t_arcs('v', my.t,
list(v_gt,c_gt,a_gt,d_gt),
sims.dat),
.(v_gt,c_gt,a_gt,d_gt)]
}
dt.sed.poly.tst[, sed_gt := sample(c(0,1), .N, prob = c(1-p_h_der,p_h_der), replace=T), p_h_der]
dt.sed.poly.tst[, .(sum(sed_gt) / .N, .N), .(p_h_der)]
mh.sites = dt.sed.poly.tst[, sample(.N, .N*my.mh_contam)]
dt.sed.poly.tst[mh.sites, .N, keyby=sed_gt]
dt.sed.poly.tst[mh.sites, sed_gt := sample(c(0,1), .N, prob=c(1-f_mh,f_mh), replace=T), f_mh]
dt.sed.poly.tst[mh.sites, .(sum(sed_gt)/.N, mean(f_mh))]
#
err.sites = dt.sed.poly.tst[, sample(.N, .N*err_rate)]
dt.sed.poly.tst[err.sites, .N, sed_gt]
dt.sed.poly.tst[err.sites, sed_gt := sample(c(0,1), .N, prob=c(.5,.5), replace=T)]
dt.sed.poly.tst[err.sites, .N, sed_gt]
dt.sed.poly.tst
}
if (F) {
simulate_data_sed('bt', .75, sims.dat)
simulate_data_sed('bt2', .75, sims.dat)
simulate_data_sed('bt3', .75, sims.dat)
simulate_data_sed('simple', .75, sims.dat)[v_gt == 0 & c_gt == 0 & a_gt == 0]
simulate_data_sed('full', .75, sims.dat)[v_gt == 0 & c_gt == 0 & a_gt == 0]
}
eval_sed_t_and_mh <- function(dt.sed.poly.tst, p_h_method, max.iter = 100, set.faunal_prop = 0) {
## constrain mh and faunal = 0, just estimate time with EM
x.em = sed_EM(dt.sed.poly.tst, sims.dat, my.branch = 'v', err_rate = 0.001, max.iter = 4, set.faunal_prop = 0, set.mh_contam = 0, p_h_method = p_h_method)
## the ll goes up and down a bit in the trace sometimes?  just not 100% stable?
# plot(tail(x.em$man.ll.trace,9))
# plot(tail(x.em$ll.trace,9))
## do "grid" search, just estimating time
dt.sed.poly.tst.gridll = sed_grid_search(dt.sed.poly.tst, sims.dat, my.branch = 'v', err_rate = 0.001, p_h_method = p_h_method,
bins.mh_contam = 1, bins.faunal_prop = 1, bins.t = 10, nsteps = 2,
range.mh_contam = c(0,0), range.faunal_prop = c(0,0),
range.t = sims.dat$branch.bounds[branch == 'v', c(t.low, t.high)])
## do EM search, estimating time and MH contam
x.em.all_params.n100 = sed_EM(dt.sed.poly.tst, sims.dat, my.branch = 'v', err_rate = 0.001,
max.iter = max.iter, ll.converge = 1e-10,
set.faunal_prop = set.faunal_prop, p_h_method = p_h_method)
dt.sed.poly.tst.gridll.all_params = sed_grid_search(dt.sed.poly.tst, sims.dat, my.branch = 'v', err_rate = 0.001, p_h_method = p_h_method,
bins.mh_contam = 10, bins.faunal_prop = 1, bins.t = 10, nsteps = 3,
range.mh_contam = c(0,.2), range.faunal_prop = c(0,0),
range.t = sims.dat$branch.bounds[branch == 'v', c(t.low, t.high)])
em.mismatch = dt.sed.poly.tst.gridll.all_params[is.max == T, ll] - x.em.all_params.n100$man.max.ll
return(list(x.em = x.em,
dt.sed.poly.tst.gridll = dt.sed.poly.tst.gridll,
x.em.all_params.n100 = x.em.all_params.n100,
dt.sed.poly.tst.gridll.all_params = dt.sed.poly.tst.gridll.all_params,
em.mismatch = em.mismatch))
}
plot_eval_sed_t_and_mh <- function(eval.ret, true_branchtime = 0.75, true_mh_contam = 0, plot.0 = F, plot.title = NULL) {
## constrain mh and faunal = 0, just estimate time with EM
if (plot.0) {
## plot them, they match!
p1 <- ggplot(eval.ret$dt.sed.poly.tst.gridll, aes(x=my.t, y=ll)) + geom_point() +
geom_point(aes(x=eval.ret$x.em$branchtime, y=eval.ret$x.em$man.max.ll), color='red', pch='x', size=10) +
xlab('branch time estimate grid vs EM (red x)') +
geom_vline(xintercept = eval.ret$dt.sed.poly.tst.gridll[is.max == T, my.t], color='green', lty=3) +
geom_vline(xintercept = true_branchtime)
if (!is.null(plot.title)) {
p1 <- p1 + ggtitle(plot.title)
}
print(p1)
}
p2 <-   ggplot(eval.ret$dt.sed.poly.tst.gridll.all_params[step.x > 0],
aes(x=my.t, y=mh_contam, color=ll)) +
geom_point() +
geom_point(data=eval.ret$dt.sed.poly.tst.gridll.all_params[max(ll) - ll < eval.ret$em.mismatch & step.x > 0], color='red') +
geom_point(data=eval.ret$dt.sed.poly.tst.gridll.all_params[max(ll) - ll < eval.ret$em.mismatch/10 & step.x > 0], color='green') +
geom_path(data=data.table(my.t = rep(eval.ret$x.em.all_params.n100$branchtime.trace,
each = length(unique(eval.ret$x.em.all_params.n100$dt.theta.trace$rg))),
eval.ret$x.em.all_params.n100$dt.theta.trace),
aes(group = rg),
color='red') +
geom_point(data = data.table(x=rep(true_branchtime, length(true_mh_contam)), y=true_mh_contam),
aes(x=x,y=y), color='black', pch='x', size=10) +
geom_point(data = data.table(x=rep(eval.ret$x.em.all_params.n100$branchtime,
length(eval.ret$x.em.all_params.n100$dt.theta$mh_contam)),
y=eval.ret$x.em.all_params.n100$dt.theta$mh_contam),
aes(x=x,y=y), color='slateblue1', pch='x', size=10) +
geom_point(data=eval.ret$dt.sed.poly.tst.gridll.all_params[max(ll) == ll], color='black', pch='*', size=4) +
xlab('branch time estimate grid (green/red dots) vs EM (red x)') + ylab('mh contam estimate') +
coord_cartesian(ylim = c(0,.3)) +
ggtitle(sprintf('ll of red points within %g of EM ll; red line is EM trace', eval.ret$em.mismatch))
if (!is.null(plot.title)) {
p2 <- p2 + ggtitle(plot.title)
}
# dt.sed.analysis.mh_all.contam1.x4.one_rg2.simple.fixed_anc_p_0.004$dt.sed.poly.tst.gridll.all_params[ll == max(ll)]
#
print(p2)
}
if (F) {
## very very simple fake data, using p_der=bt
dt.sed.poly.tst <- simulate_data_sed('bt', .75, sims.dat)
eval.ret.bt <- eval_sed_t_and_mh(dt.sed.poly.tst, 'bt')
plot_eval_sed_t_and_mh(eval.ret.bt)
## slightly more complicated fake data, using bt2, p_der=bt/(gt_c+1)
dt.sed.poly.tst.bt2 <- simulate_data_sed('bt2', .75, sims.dat)
eval.ret.bt2 <- eval_sed_t_and_mh(dt.sed.poly.tst.bt2, p_h_method = 'bt2')
plot_eval_sed_t_and_mh(eval.ret.bt2)
## same scenario, but randomly shuffle the sediment data
dt.sed.poly.tst.bt2.shuf <- data.table(dt.sed.poly.tst.bt2)
dt.sed.poly.tst.bt2.shuf[, sed_gt := sample(sed_gt)]
eval.ret.bt2.shuf <- eval_sed_t_and_mh(dt.sed.poly.tst.bt2.shuf, p_h_method = 'bt2')
plot_eval_sed_t_and_mh(eval.ret.bt2.shuf)
## slightly more complicated fake data, using bt3, p_der=bt/(gt_c+1) and p_der=0 if altai=0
dt.sed.poly.tst.bt3 <- simulate_data_sed('bt3', .75, sims.dat)
eval.ret.bt3 <- eval_sed_t_and_mh(dt.sed.poly.tst.bt3, p_h_method = 'bt3')
plot_eval_sed_t_and_mh(eval.ret.bt3)
## use the real simulated model, but have p_der change linearly along a branch
## (rather than with a fitted spline)
dt.sed.poly.tst.simple <- simulate_data_sed('simple', .75, sims.dat)
eval.ret.simple <- eval_sed_t_and_mh(dt.sed.poly.tst.simple, p_h_method = 'simple')
plot_eval_sed_t_and_mh(eval.ret.simple)
## use the real simulated model, but have p_der modeled with a fitted spline
dt.sed.poly.tst.full <- simulate_data_sed('full', .75, sims.dat)
eval.ret.full <- eval_sed_t_and_mh(dt.sed.poly.tst.full, p_h_method = 'full', max.iter = 20)
plot_eval_sed_t_and_mh(eval.ret.full)
##
}
ll_ret_to_dt2 <- function(my.ret, args) {
dt.theta = data.table(my.ret$dt.theta)
dt.theta[, true_mh_contam := args$add_contam]
dt.theta[, true_faunal_prop := args$add_faunal]
dt = data.table(max.ll = my.ret$max.ll,
branch = my.ret$branch,
true_branch = args$true_branch,
branchtime = my.ret$branchtime,
true_branchtime = args$true_branchtime,
branchtime.rel = (my.ret$branchtime - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)) /
(sims.dat$bounds.for.branch(my.ret$branch, 'high', sims.dat) - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)),
max.ll.iter = length(my.ret$ll.trace),
next.ll = tail(my.ret$ll.trace,2)[1],
lib = paste0(args$libs, collapse = '_'),
tag = args$tag)
}
ll_ret_to_dt2(x.em, 'args')
args$add_contam
args
args$add_contam
ll_ret_to_dt2(x.em, args)
parser$add_argument("-true-branch", "--true-branch", required=F, default=NA,
help="The simulated branchtime, used in plots and tables.")
parser$add_argument("-true-branch", "--true-branch", required=F, default=NA,
help="The simulated branch, used in plots and tables.")
parser$add_argument("-true-branchtime", "--true-branchtime", required=F, default=NA,
help="The simulated branchtime, used in plots and tables.")
parser <- ArgumentParser()
parser$add_argument("-v", "--verbose", action="store_true", default=F,
help="Print extra output")
parser$add_argument("-nc", "--ncores", type='integer', default=1,
help="Number of cores to use. [not currently used?]")
parser$add_argument("-sims", "--sims.dat", required = T,
help="")
parser$add_argument("-gts", "--simple-gts", required=T,
help="all_simple_gts.tsv.gz")
parser$add_argument("-table", "--output-table", required=F,
help="Save the results to <output-table> in tsv form.")
parser$add_argument("-true-branch", "--true-branch", required=F, default=NA,
help="The simulated branch, used in plots and tables.")
parser$add_argument("-true-branchtime", "--true-branchtime", required=F, default=NA,
help="The simulated branchtime, used in plots and tables.")
parser$add_argument("-set-mh-contam", "--set-mh-contam", required=F, default='estim',
help="If provided, constrain MH contamination to this value. [currently only works with a single value, across all RG]")
parser$add_argument("-set-faunal-prop", "--set-faunal-prop", required=F, default='estim',
help="If provided, constrain faunal proportion to this value. [currently only works with a single value, across all RG]")
parser$add_argument("-branch", "--branch", required=F, default=NULL,
help="Only run the EM on a single branch. e.g. --branch v")
parser$add_argument("-sample-mh", "--sample-mh-from-freqs", default=F, action='store_true',
help="Sample the mh 'contamination' from f_mh frequencies rather than a separate column mh")
parser$add_argument("-libs", "--libs", required=F,
help="One or more libraries to group together. The EM still treats them as separate read groups.  To treat these as a single read group, use --merge-libs.")
parser$add_argument("-merge-libs", "--merge-libs", action="store_true", default=F,
help="Merge all requested libraries into a single read group (or entire file, if --libs not given).")
parser$add_argument("-tag", "--tag", required=F, default='none',
help="One (or more, in the future) tags for this analysis.")
parser$add_argument("-niter", "--num-iters", type='integer', default=100,
help="Number of EM iterations")
parser$add_argument("-n-qc1", "--n-qc1", type='integer', default=1000,
help="Artificially add N QC sites that are DERIVED in all hominins. These are used for calculating faunal proportions, and have to be artificially added to simulated data.")
parser$add_argument("-n-qc0", "--n-qc0", type='integer', default=0,
help="Artificially add N QC sites that are ANCESTRAL in all hominins. These are not present/useful in real data, so this should mostly be used for debugging.")
parser$add_argument("-downsample", "--downsample", type='integer', default=NULL,
help="Downsample data to N reads. This samples the entire dataset, so e.g. if originally each read group was 25% of the data, these proportions may change.")
parser$add_argument("-add-contam", "--add-contam", type='double', default=0, nargs='+',
help="Artificially add contamination in these proportions")
parser$add_argument("-add-faunal", "--add-faunal", type='double', default=0, nargs='+',
help='Artificially add faunal "contamination" in these proportions')
parser$add_argument("-rg-props", "--rg-props", type='double', default=1, nargs='+',
help="Randomly split the simulations into read groups with these proportions")
parser$add_argument("-sites", "--site-cat", required=F, default = 'all',
help='Site categories to use [not currently implemented]')
parser$add_argument("-method", "--sim-method", required=F, default = 'simple',
help='Site categories to use [not currently implemented]')
parser$add_argument("-prefix", "--prefix", required=T,
help="Prefix for output files.")
if (interactive()) {
# args <- parser$parse_args(strsplit('-gts ~/Downloads/all_simple_gts.tsv.gz --sims ~/Documents/soil_dna_capture/sims.dat.RDS -libs A17273 --prefix what -nc 2', split = ' ')[[1]])
# args <- parser$parse_args(strsplit('-gts "~/GoogleDrive/branch_point_estimates/all_simple_gts.tsv.gz" --sims "~/GoogleDrive/branch_point_estimates/sims.dat.RDS" -libs A20281 --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/Downloads/all_simple_gts.small.tsv.gz --sims ~/Downloads/sims.dat.RDS -libs A20281 --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/Downloads/hey.gt.txt.gz --sims ~/Downloads/sims.dat.RDS --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/Downloads/test_sims_v_0.7601_ALL.gt.txt.gz --sims ~/Downloads/sims.dat.RDS --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/GoogleDrive/branch_point_esimates/data/test_sims_v_0.7601_ALL.gt.txt.gz --sims ~/GoogleDrive/branch_point_esimates/data/sims.dat.RDS --prefix what -nc 2 -sites all -tag hey --sim-method simple --libs sims009.v.0.7601.1 --rg-props .2 .8 --add-contam 0 .1 --downsample 10000 --n-qc1 1000 --branch v -niter 5', split = ' ')[[1]])
# args <- parser$parse_args(strsplit('--splits ~/Documents/index_cross_contam/data/ludovic/splitstats_ludovic_orlando_001.myformat3.txt -nhits 100 --prefix splitstats_ludovic_orlando_001 -nc 2 --sources 150', split = ' ')[[1]])
} else {
args <- parser$parse_args()
}
# create parser object
parser <- ArgumentParser()
parser$add_argument("-v", "--verbose", action="store_true", default=F,
help="Print extra output")
parser$add_argument("-nc", "--ncores", type='integer', default=1,
help="Number of cores to use. [not currently used?]")
parser$add_argument("-sims", "--sims.dat", required = T,
help="")
parser$add_argument("-gts", "--simple-gts", required=T,
help="all_simple_gts.tsv.gz")
parser$add_argument("-table", "--output-table", required=F,
help="Save the results to <output-table> in tsv form.")
parser$add_argument("-true-branch", "--true-branch", required=F, default='NA',
help="The simulated branch, used in plots and tables.")
parser$add_argument("-true-branchtime", "--true-branchtime", required=F, default='NA',
help="The simulated branchtime, used in plots and tables.")
parser$add_argument("-set-mh-contam", "--set-mh-contam", required=F, default='estim',
help="If provided, constrain MH contamination to this value. [currently only works with a single value, across all RG]")
parser$add_argument("-set-faunal-prop", "--set-faunal-prop", required=F, default='estim',
help="If provided, constrain faunal proportion to this value. [currently only works with a single value, across all RG]")
parser$add_argument("-branch", "--branch", required=F, default=NULL,
help="Only run the EM on a single branch. e.g. --branch v")
parser$add_argument("-sample-mh", "--sample-mh-from-freqs", default=F, action='store_true',
help="Sample the mh 'contamination' from f_mh frequencies rather than a separate column mh")
parser$add_argument("-libs", "--libs", required=F,
help="One or more libraries to group together. The EM still treats them as separate read groups.  To treat these as a single read group, use --merge-libs.")
parser$add_argument("-merge-libs", "--merge-libs", action="store_true", default=F,
help="Merge all requested libraries into a single read group (or entire file, if --libs not given).")
parser$add_argument("-tag", "--tag", required=F, default='none',
help="One (or more, in the future) tags for this analysis.")
parser$add_argument("-niter", "--num-iters", type='integer', default=100,
help="Number of EM iterations")
parser$add_argument("-n-qc1", "--n-qc1", type='integer', default=1000,
help="Artificially add N QC sites that are DERIVED in all hominins. These are used for calculating faunal proportions, and have to be artificially added to simulated data.")
parser$add_argument("-n-qc0", "--n-qc0", type='integer', default=0,
help="Artificially add N QC sites that are ANCESTRAL in all hominins. These are not present/useful in real data, so this should mostly be used for debugging.")
parser$add_argument("-downsample", "--downsample", type='integer', default=NULL,
help="Downsample data to N reads. This samples the entire dataset, so e.g. if originally each read group was 25% of the data, these proportions may change.")
parser$add_argument("-add-contam", "--add-contam", type='double', default=0, nargs='+',
help="Artificially add contamination in these proportions")
parser$add_argument("-add-faunal", "--add-faunal", type='double', default=0, nargs='+',
help='Artificially add faunal "contamination" in these proportions')
parser$add_argument("-rg-props", "--rg-props", type='double', default=1, nargs='+',
help="Randomly split the simulations into read groups with these proportions")
parser$add_argument("-sites", "--site-cat", required=F, default = 'all',
help='Site categories to use [not currently implemented]')
parser$add_argument("-method", "--sim-method", required=F, default = 'simple',
help='Site categories to use [not currently implemented]')
parser$add_argument("-prefix", "--prefix", required=T,
help="Prefix for output files.")
if (interactive()) {
# args <- parser$parse_args(strsplit('-gts ~/Downloads/all_simple_gts.tsv.gz --sims ~/Documents/soil_dna_capture/sims.dat.RDS -libs A17273 --prefix what -nc 2', split = ' ')[[1]])
# args <- parser$parse_args(strsplit('-gts "~/GoogleDrive/branch_point_estimates/all_simple_gts.tsv.gz" --sims "~/GoogleDrive/branch_point_estimates/sims.dat.RDS" -libs A20281 --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/Downloads/all_simple_gts.small.tsv.gz --sims ~/Downloads/sims.dat.RDS -libs A20281 --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/Downloads/hey.gt.txt.gz --sims ~/Downloads/sims.dat.RDS --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/Downloads/test_sims_v_0.7601_ALL.gt.txt.gz --sims ~/Downloads/sims.dat.RDS --prefix what -nc 2 -sites all -tag hey', split = ' ')[[1]])
args <- parser$parse_args(strsplit('-gts ~/GoogleDrive/branch_point_esimates/data/test_sims_v_0.7601_ALL.gt.txt.gz --sims ~/GoogleDrive/branch_point_esimates/data/sims.dat.RDS --prefix what -nc 2 -sites all -tag hey --sim-method simple --libs sims009.v.0.7601.1 --rg-props .2 .8 --add-contam 0 .1 --downsample 10000 --n-qc1 1000 --branch v -niter 5', split = ' ')[[1]])
# args <- parser$parse_args(strsplit('--splits ~/Documents/index_cross_contam/data/ludovic/splitstats_ludovic_orlando_001.myformat3.txt -nhits 100 --prefix splitstats_ludovic_orlando_001 -nc 2 --sources 150', split = ' ')[[1]])
} else {
args <- parser$parse_args()
}
ll_ret_to_dt2(x.em, args)
ll_ret_to_dt2 <- function(my.ret, args) {
dt.theta = data.table(my.ret$dt.theta)
dt.theta[, true_mh_contam := args$add_contam]
dt.theta[, true_faunal_prop := args$add_faunal]
dt = data.table(max.ll = my.ret$max.ll,
branch = my.ret$branch,
true_branch = args$true_branch,
branchtime = my.ret$branchtime,
true_branchtime = args$true_branchtime,
branchtime.rel = (my.ret$branchtime - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)) /
(sims.dat$bounds.for.branch(my.ret$branch, 'high', sims.dat) - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)),
max.ll.iter = length(my.ret$ll.trace),
next.ll = tail(my.ret$ll.trace,2)[1],
lib = paste0(args$libs, collapse = '_'),
tag = args$tag)
cbind(dt, dt.theta)
}
ll_ret_to_dt2(x.em, args)
rm(ll_ret_to_dt2)
ll_ret_to_dt_sims <- function(my.ret, args) {
dt.theta = data.table(my.ret$dt.theta)
dt.theta[, true_mh_contam := args$add_contam]
dt.theta[, true_faunal_prop := args$add_faunal]
dt = data.table(max.ll = my.ret$max.ll,
branch = my.ret$branch,
true_branch = args$true_branch,
branchtime = my.ret$branchtime,
true_branchtime = args$true_branchtime,
branchtime.rel = (my.ret$branchtime - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)) /
(sims.dat$bounds.for.branch(my.ret$branch, 'high', sims.dat) - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)),
max.ll.iter = length(my.ret$ll.trace),
next.ll = tail(my.ret$ll.trace,2)[1],
lib = paste0(args$libs, collapse = '_'),
tag = args$tag)
cbind(dt, dt.theta)
}
source('~/GoogleDrive/branch_point_esimates/R/estim_branchpoints_from_sims.R', echo=TRUE)
args$output_table
getwd()
args <- parser$parse_args(strsplit('-gts ~/GoogleDrive/branch_point_esimates/data/test_sims_v_0.7601_ALL.gt.txt.gz --sims ~/GoogleDrive/branch_point_esimates/data/sims.dat.RDS --prefix what -nc 2 -sites all -tag hey --sim-method simple --libs sims009.v.0.7601.1 --rg-props .2 .8 --add-contam 0 .1 --downsample 10000 --n-qc1 1000 --branch v -niter 5 -table hey.txt', split = ' ')[[1]])
fwrite(ll_ret_to_dt_sims(x.em, args), args$output_table)
fwrite(ll_ret_to_dt_sims(x.em, args), args$output_table, sep='\t')
?here
thisFile <- function() {
cmdArgs <- commandArgs(trailingOnly = FALSE)
needle <- "--file="
match <- grep(needle, cmdArgs)
if (length(match) > 0) {
# Rscript
return(normalizePath(sub(needle, "", cmdArgs[match])))
} else {
# 'source'd via R console
return(normalizePath(sys.frames()[[1]]$ofile))
}
}
thisFile()
cmdArgs <- commandArgs(trailingOnly = FALSE)
needle <- "--file="
needle
match <- grep(needle, cmdArgs)
match
sys.frames()[[1]]$ofile
sub(needle, "", cmdArgs[match])
ll_ret_to_dt_sims <- function(my.ret, args) {
dt.theta = data.table(my.ret$dt.theta)
dt.theta[, true_mh_contam := args$add_contam]
dt.theta[, true_faunal_prop := args$add_faunal]
dt = data.table(max.ll = my.ret$max.ll,
branch = my.ret$branch,
true_branch = args$true_branch,
branchtime = my.ret$branchtime,
true_branchtime = args$true_branchtime,
branchtime.rel = (my.ret$branchtime - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)) /
(sims.dat$bounds.for.branch(my.ret$branch, 'high', sims.dat) - sims.dat$bounds.for.branch(my.ret$branch, 'low', sims.dat)),
max.ll.iter = length(my.ret$ll.trace),
next.ll = tail(my.ret$ll.trace,2)[1],
lib = paste0(args$libs, collapse = '_'),
downsample = args$downsample,
tag = args$tag)
cbind(dt, dt.theta)
}
sims.dat$bounds.for.branch()
sims.dat$branch.bounds
a = data.table(sims.dat$branch.bounds)
setnames(a, 'branch', 'hey')
a
a = data.table(sims.dat$branch.bounds)
a.newname = 'hey'
a = data.table(sims.dat$branch.bounds)
setnames(a, 'branch', a.newname)
a
setnames(a, 'hey', a.newname)
a
ggplot(dt.sed.og[, .(p = sum(mh)/.N, .N), f_mh], aes(x=f_mh, y=p, size=N)) + geom_point()
dt.sed.og$mh[!is.na(dt.sed.og$f_mh)] <- sapply(dt.sed.og[!is.na(dt.sed.og$f_mh), f_mh], function(f_mh) sample(0:1, 1, prob = c(1-f_mh,f_mh)))
ggplot(dt.sed.og[, .(p = sum(mh)/.N, .N), f_mh], aes(x=f_mh, y=p, size=N)) + geom_point()
dt.sed.og
dt.sed.og[sample(.N, 100000)]
dt.sed.og[sample(.N, 100000), f_mh := NA]
dt.sed.og$mh[!is.na(dt.sed.og$f_mh)] <- sapply(dt.sed.og[!is.na(dt.sed.og$f_mh), f_mh], function(f_mh) sample(0:1, 1, prob = c(1-f_mh,f_mh)))
ggplot(dt.sed.og[, .(p = sum(mh)/.N, .N), f_mh], aes(x=f_mh, y=p, size=N)) + geom_point()
?q
a
complete.cases(a)
fg
source('~/GoogleDrive/branch_point_esimates/R/estim_branchpoints_from_sims.R', echo=TRUE)
